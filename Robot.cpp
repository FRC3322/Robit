// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Robot.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
Drivetrain* Robot::drivetrain = 0;
Climber* Robot::climber = 0;
Shooter* Robot::shooter = 0;
Gatherer* Robot::gatherer = 0;
Camera* Robot::camera = 0;
Support* Robot::support = 0;
Cosmetic* Robot::cosmetic = 0;
OI* Robot::oi = 0;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	drivetrain = new Drivetrain();
	climber = new Climber();
	shooter = new Shooter();
	gatherer = new Gatherer();
	camera = new Camera();
	support = new Support();
	cosmetic = new Cosmetic();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi = new OI();
	lw = LiveWindow::GetInstance();
	teleopLastStartTime = 0;
	log = 0;
	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	autonomousCommand = new AutonomousCommand();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
}
void Robot::DisabledInit() {
	if (log) {
		fclose(log);
	}
	log = 0;
}
void Robot::DisabledPeriodic() {
}
// taskPrioritySet(tid, 0) ---> taskPrioritySet(tid, priority)
// taskLock() ---> taskUnlock()
#define RUN_TIMER_TEST(F) \
elapsed = last = Timer::GetPPCTimestamp(); \
for (j = 0; j < NumInnerIters; ++j) { \
	now = F(); \
	dt = now - last; \
	if (j > 0) { \
		if (dt > max_dt) max_dt = dt; \
		if (dt < min_dt) min_dt = dt; \
	} \
	else { \
		max_dt = 0.0; \
		min_dt = 1.0; \
	} \
	last = now; \
} \
elapsed = Timer::GetPPCTimestamp() - elapsed; \
avg_dt = elapsed / NumInnerIters;
void Robot::AutonomousInit() {
	if (log) {
		fclose(log);
	}
#if 0
	if (0 != (log = fopen("/3322-timing.txt", "w"))) {
		fprintf(log, "TIMING TEST\n");
		const int NumOuterIters = 10;
		const int NumInnerIters = 1000;
		int i, j;
		double elapsed, now, last, dt, min_dt, max_dt, avg_dt;
		int tid, priority;
		tid = taskIdSelf();
		taskPriorityGet(tid, &priority);
		for (i = 0; i < NumOuterIters; ++i) {
			RUN_TIMER_TEST(Timer::GetFPGATimestamp)
			fprintf(log, "FPGA,%.8f,%.8f,%.8f\n", avg_dt, min_dt, max_dt);
		}
		for (i = 0; i < NumOuterIters; ++i) {
			RUN_TIMER_TEST(::GetTime)
			fprintf(log, "GetTime,%.8f,%.8f,%.8f\n", avg_dt, min_dt, max_dt);
		}
		for (i = 0; i < NumOuterIters; ++i) {
			RUN_TIMER_TEST(Timer::GetPPCTimestamp)
			fprintf(log, "PPC,%.8f,%.8f,%.8f\n", avg_dt, min_dt, max_dt);
		}
		fclose(log);
	}
#endif
	log = 0;
#if 0
	if (autonomousCommand != NULL)
		autonomousCommand->Start();
#endif
}
	
void Robot::AutonomousPeriodic() {
#if 0
	Scheduler::GetInstance()->Run();
#endif
}
void Robot::TeleopInit() {
	if (log) {
		fclose(log);
	}
	double startTime = Timer::GetPPCTimestamp();
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to 
	// continue until interrupted by another command, remove
	// this line or comment it out.
	autonomousCommand->Cancel();
	RobotMap::supportCompressor->Start();
	//Robot::support->gyro->SetSensitivity(0.05);
	Robot::support->gyro->Reset();
	double endTime = Timer::GetPPCTimestamp();
	if (0 != (log = fopen("/3322-teleop.txt", "a"))) {
		fprintf(log, "%.8f,%.8f,%.8f,TI\n",
				startTime, startTime-teleopLastStartTime, endTime-startTime);
	}
	teleopLastStartTime = startTime;
}
#define COLLECT_DIAGNOSTICS 1
void Robot::TeleopPeriodic() {
	Robot::support->perfTimer->Set(1);
#ifdef COLLECT_DIAGNOSTICS
	double startTime = Timer::GetPPCTimestamp();
#endif
	double gyroAngle = Robot::support->gyro->GetAngle();
	SmartDashboard::PutNumber("gyro", gyroAngle);
	if (autonomousCommand != NULL)
		Scheduler::GetInstance()->Run();
	Robot::support->perfTimer->Set(0);
#ifdef COLLECT_DIAGNOSTICS
	double endTime = Timer::GetPPCTimestamp();
	Robot::support->diagTimer->Set(1);
	if (log) {
		fprintf(log, "%.8f,%.8f,%.8f,T,%.2f\n",
				startTime, startTime-teleopLastStartTime, endTime-startTime,
				gyroAngle);
		fflush(log);
	}
	teleopLastStartTime = startTime;
	Robot::support->diagTimer->Set(0);
#endif
}
void Robot::TestInit() {
	if (log) {
		fclose(log);
	}
	log = 0;
}
void Robot::TestPeriodic() {
	lw->Run();
}
START_ROBOT_CLASS(Robot);
