#include "Robot.h"
#include <math.h>
#ifndef M_PI
# define M_PI 3.1415926535
#endif
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
Drivetrain* Robot::drivetrain = 0;
Climber* Robot::climber = 0;
Shooter* Robot::shooter = 0;
Gatherer* Robot::gatherer = 0;
Camera* Robot::camera = 0;
Support* Robot::support = 0;
Cosmetic* Robot::cosmetic = 0;
OI* Robot::oi = 0;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
Diagnostics* Robot::diag = 0;
void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	drivetrain = new Drivetrain();
	climber = new Climber();
	shooter = new Shooter();
	gatherer = new Gatherer();
	camera = new Camera();
	support = new Support();
	cosmetic = new Cosmetic();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	oi = new OI();
	lw = LiveWindow::GetInstance();
	diag = new Diagnostics();
	autonomousCommand = 0;
	gyroGood = true;
	driveEncodersGood = true;
}
#define COLLECT_DIAGNOSTICS 1
void Robot::DisabledInit() {
	Robot::ResetDistanceTraveled();
	Robot::diag->FlushToDisk();
}
void Robot::DisabledPeriodic() {
	// FIXME Test gyro and encoders to verify they are working.
	// This can be done during pre-match setup: push the robot
	// forward and backward a few inches, then turn the robot left
	// and right a few degrees. A calibration switch on the robot
	// should be used to enter this verification mode.
}
void Robot::AutonomousInit() {
	double startTime = Timer::GetPPCTimestamp();
	RobotMap::supportCompressor->Start();
	Robot::ResetDistanceTraveled();
	if(autonomousCommand)
		autonomousCommand->Start();
	double endTime = Timer::GetPPCTimestamp();
	Snapshot("AI", startTime, endTime);
}
void Robot::AutonomousPeriodic() {
#if COLLECT_DIAGNOSTICS
	double startTime = Timer::GetPPCTimestamp();
#endif
	Robot::shooter->shooterSpeed = Robot::shooter->mainMotor->GetSpeed();
	Scheduler::GetInstance()->Run();
#if COLLECT_DIAGNOSTICS
	Robot::drivetrain->Snapshot();
	Robot::shooter->Snapshot();
	double endTime = Timer::GetPPCTimestamp();
	Snapshot("A", startTime, endTime);
#endif
}
void Robot::TeleopInit() {
	double startTime = Timer::GetPPCTimestamp();
	if(autonomousCommand)
		autonomousCommand->Cancel();
	RobotMap::supportCompressor->Start();
	Robot::ResetDistanceTraveled();
	double endTime = Timer::GetPPCTimestamp();
	Snapshot("TI", startTime, endTime);
}
void Robot::TeleopPeriodic() {
#if COLLECT_DIAGNOSTICS
	double startTime = Timer::GetPPCTimestamp();
#endif
	// FIXME refactor this into a periodic function that will be called
	// at the start of each auton and teleop period tick. The same technique
	// can be used for shooter and drivetrain. It's a good place to verify
	// and reconfigure the Jaguars.
	Robot::shooter->shooterSpeed = Robot::shooter->mainMotor->GetSpeed();
	SmartDashboard::PutNumber("jaguarRPM", Robot::shooter->shooterSpeed);
	SmartDashboard::PutNumber("gyro", Robot::support->gyro->GetAngle());
	SmartDashboard::PutNumber("leftEncoder", Robot::drivetrain->leftEncoder->GetRaw());
	SmartDashboard::PutNumber("rightEncoder", Robot::drivetrain->rightEncoder->GetRaw());
	SmartDashboard::PutNumber("facing", Robot::AngleFacing());
	SmartDashboard::PutNumber("distance", Robot::DistanceTraveled());
	Robot::drivetrain->drive->leftRightAdjust = SmartDashboard::GetNumber("LeftRightAdjust");
	Scheduler::GetInstance()->Run();
#if COLLECT_DIAGNOSTICS
	Robot::drivetrain->Snapshot();
	Robot::shooter->Snapshot();
	double endTime = Timer::GetPPCTimestamp();
	Snapshot("T", startTime, endTime);
#endif
}
void Robot::TestInit() {
}
void Robot::TestPeriodic() {
	lw->Run();
}
START_ROBOT_CLASS(Robot);
void Robot::Snapshot(char *mode, double start, double end) {
	const char *format = (end - start >= 0.018) ? "%s,%.4f,%.4f,SLOW\n" : "%s,%.4f,%.4f\n";
	Robot::diag->BufferPrintf(format, mode, start, end);
}
void Robot::ResetDistanceTraveled() {
	Robot::support->gyro->Reset();
	Robot::drivetrain->leftEncoder->Reset();
	Robot::drivetrain->rightEncoder->Reset();
}
double Robot::DistanceTraveled() {
	double leftDist = Robot::drivetrain->leftEncoder->GetDistance();
	double rightDist = Robot::drivetrain->rightEncoder->GetDistance();
	double dist = max(leftDist, rightDist);
	return dist;
}
double Robot::AngleFacing() {
	if (Robot::gyroGood) {
		return Robot::support->gyro->GetAngle();
	}
	else if (Robot::driveEncodersGood) {
		const double RobotWidth = 26.0;
		double rad = (Robot::drivetrain->leftEncoder->GetDistance() -
					  Robot::drivetrain->rightEncoder->GetDistance()) / RobotWidth;
		return rad * (180.0 / M_PI);
	}
	else {
		return 0.0;
	}
}
